<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>TFCChato documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avaoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-block d-sm-none">
            <a href="../" class="navbar-brand">TFCChato documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  FirebaseStorageFile</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/core/services/firebase/firebase.service.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#file" 
>
                                            file
                                        </a>
                                </li>
                                <li>
                                        <a href="#path" 
>
                                            path
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="file"></a>
                                        <span class="name "><b>file</b>
                                            <a href="#file">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>file:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="path"></a>
                                        <span class="name "><b>path</b>
                                            <a href="#path">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>path:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Inject, Injectable } from &#x27;@angular/core&#x27;;
import { BehaviorSubject, Observable } from &#x27;rxjs&#x27;;
import { initializeApp, getApp, FirebaseApp } from &#x27;firebase/app&#x27;;
import {
  getFirestore,
  addDoc,
  collection,
  updateDoc,
  doc,
  onSnapshot,
  getDoc,
  setDoc,
  query,
  where,
  getDocs,
  Unsubscribe,
  DocumentData,
  deleteDoc,
  Firestore,
  DocumentReference,
  DocumentSnapshot,
  FieldPath,
  CollectionReference,
} from &#x27;firebase/firestore&#x27;;
import {
  getStorage,
  ref,
  getDownloadURL,
  uploadBytes,
  FirebaseStorage,
} from &#x27;firebase/storage&#x27;;
import {
  createUserWithEmailAndPassword,
  deleteUser,
  signInAnonymously,
  signOut,
  signInWithEmailAndPassword,
  initializeAuth,
  indexedDBLocalPersistence,
  UserCredential,
  Auth,
  User,
} from &#x27;firebase/auth&#x27;;
import { UserInfo } from &#x27;../../interfaces/user-info&#x27;;

export interface FirebaseStorageFile {
  path: string;
  file: string;
}

export interface FirebaseDocument {
  id: string;
  data: DocumentData;
}

export interface FirebaseUserCredential {
  user: UserCredential;
}

@Injectable({
  providedIn: &#x27;root&#x27;,
})
export class FirebaseService {
  private _app!: FirebaseApp;
  private _db!: Firestore;
  private _auth!: Auth;
  private _webStorage!: FirebaseStorage;
  private _user: User | null &#x3D; null;
  private _isLogged: BehaviorSubject&lt;boolean&gt; &#x3D; new BehaviorSubject&lt;boolean&gt;(
    false
  );
  public isLogged$: Observable&lt;boolean&gt; &#x3D; this._isLogged.asObservable();

  private _users: BehaviorSubject&lt;UserInfo[]&gt; &#x3D; new BehaviorSubject&lt;UserInfo[]&gt;(
    []
  );
  public users$: Observable&lt;UserInfo[]&gt; &#x3D; this._users.asObservable();
  private _incidents: BehaviorSubject&lt;any[]&gt; &#x3D; new BehaviorSubject&lt;any[]&gt;([]);
  public incidents$: Observable&lt;any[]&gt; &#x3D; this._incidents.asObservable();
  private _categories: BehaviorSubject&lt;any[]&gt; &#x3D; new BehaviorSubject&lt;any[]&gt;([]);
  public categories$: Observable&lt;any[]&gt; &#x3D; this._categories.asObservable();

  constructor(@Inject(&#x27;firebase-config&#x27;) config: any) {
    this.init(config);
  }

  /**
   * The &#x60;init&#x60; function initializes Firebase, sets up authentication, and subscribes to user and
   * incident collections based on the user&#x27;s authentication state.
   *
   * @param firebaseConfig The &#x60;firebaseConfig&#x60; parameter is an object that contains the configuration
   * settings needed to initialize Firebase in your application. It typically includes properties such
   * as &#x60;apiKey&#x60;, &#x60;authDomain&#x60;, &#x60;projectId&#x60;, &#x60;storageBucket&#x60;, &#x60;messagingSenderId&#x60;, &#x60;appId&#x60;, and
   * &#x60;measurementId&#x60;. These settings are unique to
   */
  public async init(firebaseConfig: any) {
    // Initialize Firebase
    this._app &#x3D; initializeApp(firebaseConfig);
    this._db &#x3D; getFirestore(this._app);
    this._webStorage &#x3D; getStorage(this._app);
    this._auth &#x3D; initializeAuth(getApp(), {
      persistence: indexedDBLocalPersistence,
    });
    this._auth.onAuthStateChanged(async (user) &#x3D;&gt; {
      this._user &#x3D; user;
      if (user) {
        if (user.uid &amp;&amp; user.email) {
          this._isLogged.next(true);
          this.subscribeToCollection(&#x27;userInfo&#x27;, this._users, (el: any) &#x3D;&gt; el);
          this.subscribeToCollection(
            &#x27;categoryInfo&#x27;,
            this._categories,
            (el: any) &#x3D;&gt; el
          );
          this.subscribeToCollection(
            &#x27;incidentsInfo&#x27;,
            this._incidents,
            (el: any) &#x3D;&gt; el
          );
        }
      } else {
        this._isLogged.next(false);
      }
    });
  }

  /**
   * Retrieves all data from specified collections in Firebase.
   *
   * @remarks
   * This method fetches data from the specified collections in Firebase Firestore.
   * It returns an object containing arrays of documents for each collection.
   *
   * @returns A Promise that resolves to an object containing arrays of documents for each collection.
   *
   * @throws Error if the data fetching process fails.
   */
  public async getAllData(): Promise&lt;{ [key: string]: any[] }&gt; {
    const collections &#x3D; [&#x27;userInfo&#x27;, &#x27;categoryInfo&#x27;, &#x27;incidentsInfo&#x27;];
    const allData: { [key: string]: any[] } &#x3D; {};

    try {
      for (const collectionName of collections) {
        const querySnapshot &#x3D; await getDocs(
          collection(this._db, collectionName)
        );
        allData[collectionName] &#x3D; querySnapshot.docs.map((doc) &#x3D;&gt; ({
          id: doc.id,
          ...doc.data(),
        }));
      }
      return allData;
    } catch (error: any) {
      throw new Error(&#x60;Failed to fetch data: ${error.message}&#x60;);
    }
  }

  /**
   * The function &#x60;getUser&#x60; returns the user object or null.
   * @returns The &#x60;user&#x60; property is being returned, which is of type &#x60;User&#x60; or &#x60;null&#x60;.
   */
  public get user(): User | null {
    return this._user;
  }

  /**
   * The function &#x60;fileUpload&#x60; uploads a file to Firebase Storage with specified metadata and returns a
   * Promise containing the path and download URL of the uploaded file.
   * @param {Blob} blob - The &#x60;blob&#x60; parameter in the &#x60;fileUpload&#x60; function is a Blob object
   * representing the data to be uploaded to Firebase Storage. Blobs represent raw data that can be of
   * any type, such as images, documents, or other binary data.
   * @param {string} mimeType - The &#x60;mimeType&#x60; parameter in the &#x60;fileUpload&#x60; function refers to the
   * type of the file being uploaded. It specifies the media type of the file, such as &quot;image/jpeg&quot; for
   * JPEG images or &quot;application/pdf&quot; for PDF files. This information is important for setting the
   * content type metadata
   * @param {string} path - The &#x60;path&#x60; parameter in the &#x60;fileUpload&#x60; function represents the location
   * in the Firebase Storage where you want to upload the file. It is a string that specifies the path
   * or directory within your Firebase Storage bucket where the file will be stored. For example, if
   * you want to upload the file to
   * @param {string} prefix - The &#x60;prefix&#x60; parameter in the &#x60;fileUpload&#x60; function is a string that is
   * used as a prefix for the file name when it is uploaded to Firebase Storage. It is concatenated
   * with the current timestamp and the specified extension to form the final file name.
   * @param {string} extension - The &#x60;extension&#x60; parameter in the &#x60;fileUpload&#x60; function represents the
   * file extension of the uploaded file. This could be something like &quot;.jpg&quot;, &quot;.png&quot;, &quot;.pdf&quot;, etc.,
   * depending on the type of file being uploaded. It is used to construct the final URL of the file in
   * the storage
   * @returns The function &#x60;fileUpload&#x60; returns a Promise that resolves to a &#x60;FirebaseStorageFile&#x60;
   * object, which contains the &#x60;path&#x60; and &#x60;file&#x60; properties.
   */
  public fileUpload(
    blob: Blob,
    mimeType: string,
    path: string,
    prefix: string,
    extension: string
  ): Promise&lt;FirebaseStorageFile&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      if (!this._webStorage || !this._auth)
        reject({
          msg: &#x27;Not connected to FireStorage&#x27;,
        });
      var freeConnection &#x3D; false;
      if (this._auth &amp;&amp; !this._auth.currentUser) {
        try {
          await signInAnonymously(this._auth);
          freeConnection &#x3D; true;
        } catch (error) {
          reject(error);
        }
      }
      const url &#x3D; path + &#x27;/&#x27; + prefix + &#x27;-&#x27; + Date.now() + extension;
      const storageRef &#x3D; ref(this._webStorage!, url);
      const metadata &#x3D; {
        contentType: mimeType,
      };
      uploadBytes(storageRef, blob)
        .then(async (snapshot) &#x3D;&gt; {
          getDownloadURL(storageRef)
            .then(async (downloadURL) &#x3D;&gt; {
              if (freeConnection) await signOut(this._auth!);
              resolve({
                path,
                file: downloadURL,
              });
            })
            .catch(async (error) &#x3D;&gt; {
              if (freeConnection) await signOut(this._auth!);
              reject(error);
            });
        })
        .catch(async (error) &#x3D;&gt; {
          if (freeConnection) await signOut(this._auth!);
          reject(error);
        });
    });
  }

  /**
   * The function &#x60;imageUpload&#x60; uploads a blob as an image file with the specified parameters.
   * @param {Blob} blob - The &#x60;blob&#x60; parameter in the &#x60;imageUpload&#x60; function is a Blob object
   * representing the image file that you want to upload. It contains the binary data of the image
   * file.
   * @returns The &#x60;imageUpload&#x60; function is returning a Promise that resolves to the result of calling
   * the &#x60;fileUpload&#x60; function with the provided parameters: &#x60;blob&#x60;, &#x60;&#x27;image/jpeg&#x27;&#x60;, &#x60;&#x27;images&#x27;&#x60;,
   * &#x60;&#x27;image&#x27;&#x60;, and &#x60;&quot;.jpg&quot;&#x60;.
   */
  public imageUpload(blob: Blob): Promise&lt;any&gt; {
    return this.fileUpload(blob, &#x27;image/jpeg&#x27;, &#x27;images&#x27;, &#x27;image&#x27;, &#x27;.jpg&#x27;);
  }

  /**
   * The function &#x60;createDocument&#x60; creates a document in a specified collection in a database and
   * returns a Promise with the document ID.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter is a string that represents the
   * name of the collection in the database where you want to create a new document.
   * @param {any} data - The &#x60;data&#x60; parameter in the &#x60;createDocument&#x60; function represents the
   * information or document that you want to add to the specified collection in the database. It can
   * be of any type (&#x60;any&#x60; in this case), allowing you to pass different kinds of data to be stored in
   * the database. This data
   * @returns The &#x60;createDocument&#x60; function returns a &#x60;Promise&#x60; that resolves to a string, which is the
   * ID of the newly created document in the specified collection.
   */
  public createDocument(collectionName: string, data: any): Promise&lt;string&gt; {
    return new Promise((resolve, reject) &#x3D;&gt; {
      if (!this._db)
        reject({
          msg: &#x27;Database is not connected&#x27;,
        });
      const collectionRef &#x3D; collection(this._db!, collectionName);
      addDoc(collectionRef, data)
        .then((docRef) &#x3D;&gt; resolve(docRef.id))
        .catch((err) &#x3D;&gt; reject(err));
    });
  }

  /**
   * The function &#x60;createDocumentWithId&#x60; creates a document with a specific ID in a specified
   * collection in a Firestore database.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter is a string that represents the
   * name of the collection in which you want to create a new document.
   * @param {any} data - The &#x60;data&#x60; parameter in the &#x60;createDocumentWithId&#x60; function represents the
   * information or document that you want to store in the specified collection with the provided
   * document ID. It can be any type of data that you want to save in the Firestore database, such as
   * an object, string, number,
   * @param {string} docId - The &#x60;docId&#x60; parameter in the &#x60;createDocumentWithId&#x60; function is a string
   * that represents the unique identifier or name of the document you want to create in the specified
   * collection. It is used to uniquely identify the document within the collection.
   * @returns A Promise is being returned.
   */
  public createDocumentWithId(
    collectionName: string,
    data: any,
    docId: string
  ): Promise&lt;void&gt; {
    return new Promise((resolve, reject) &#x3D;&gt; {
      if (!this._db) {
        reject({
          msg: &#x27;Database is not connected&#x27;,
        });
      }
      const docRef &#x3D; doc(this._db!, collectionName, docId);
      setDoc(docRef, data)
        .then(() &#x3D;&gt; resolve())
        .catch((err) &#x3D;&gt; reject(err));
    });
  }

  /**
   * This TypeScript function updates a document in a specified collection with the provided data.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter is a string that represents the
   * name of the collection in the database where the document will be updated.
   * @param {string} document - The &#x60;document&#x60; parameter in the &#x60;updateDocument&#x60; function refers to the
   * specific document within the collection that you want to update. It is typically identified by a
   * unique document ID or name within the specified collection.
   * @param {any} data - The &#x60;data&#x60; parameter in the &#x60;updateDocument&#x60; function represents the new data
   * that you want to update in the specified document within the collection. This data can be of any
   * type (&#x60;any&#x60; in this case) and should contain the updated values that you want to set in the
   * document.
   * @returns This function returns a Promise that resolves to void.
   */
  public updateDocument(
    collectionName: string,
    document: string,
    data: any
  ): Promise&lt;void&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      if (!this._db)
        reject({
          msg: &#x27;Database is not connected&#x27;,
        });
      const collectionRef &#x3D; collection(this._db!, collectionName);
      updateDoc(doc(collectionRef, document), data)
        .then((docRef) &#x3D;&gt; resolve())
        .catch((err) &#x3D;&gt; reject(err));
    });
  }

  /**
   * This function retrieves documents from a specified collection in Firebase and returns them as an
   * array of FirebaseDocument objects.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter is a string that represents the
   * name of the collection in the Firebase Firestore database from which you want to retrieve
   * documents.
   * @returns A Promise that resolves to an array of FirebaseDocument objects. Each FirebaseDocument
   * object contains an id property representing the document ID and a data property representing the
   * document data.
   */
  public getDocuments(collectionName: string): Promise&lt;FirebaseDocument[]&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      if (!this._db)
        reject({
          msg: &#x27;Database is not connected&#x27;,
        });
      const querySnapshot &#x3D; await getDocs(
        collection(this._db!, collectionName)
      );
      resolve(
        querySnapshot.docs.map&lt;FirebaseDocument&gt;((doc) &#x3D;&gt; {
          return { id: doc.id, data: doc.data() };
        })
      );
    });
  }

  /**
   * This TypeScript function retrieves documents from a Firebase collection based on a substring match
   * in the document IDs.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter refers to the name of the
   * collection in the Firebase Firestore database from which you want to retrieve documents. It is a
   * string that specifies the collection&#x27;s name.
   * @param {string} substring - The &#x60;substring&#x60; parameter in the &#x60;getDocumentsBySubstring&#x60; function is
   * a string that represents the substring you want to search for within the document IDs in a
   * specific collection. The function will return a Promise that resolves to an array of Firebase
   * documents whose IDs contain the specified substring.
   * @returns This function &#x60;getDocumentsBySubstring&#x60; returns a Promise that resolves to an array of
   * &#x60;FirebaseDocument&#x60; objects. The &#x60;FirebaseDocument&#x60; objects contain the &#x60;id&#x60; and &#x60;data&#x60; properties
   * of the documents that match the provided &#x60;substring&#x60; within the specified &#x60;collectionName&#x60;. If no
   * documents match the criteria, an empty array is returned.
   */
  public getDocumentsBySubstring(
    collectionName: string,
    substring: string
  ): Promise&lt;FirebaseDocument[]&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      if (!this._db) {
        reject({
          msg: &#x27;Database is not connected&#x27;,
        });
      }
      try {
        const allDocs &#x3D; await getDocs(collection(this._db!, collectionName));

        const filteredDocs &#x3D; allDocs.docs.filter((doc) &#x3D;&gt;
          doc.id.includes(substring)
        );

        if (filteredDocs &amp;&amp; filteredDocs.length &gt; 0) {
          resolve(
            filteredDocs.map&lt;FirebaseDocument&gt;((doc) &#x3D;&gt; {
              return { id: doc.id, data: doc.data() };
            })
          );
        } else {
          // No se encontraron documentos que coincidan con el criterio de b√∫squeda
          resolve([]);
        }
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * This TypeScript function retrieves a document from a Firebase collection and returns a Promise
   * with the document data if it exists.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter in the &#x60;getDocument&#x60; function
   * refers to the name of the collection in the Firestore database from which you want to retrieve a
   * specific document. It is a string value that specifies the collection where the document is
   * stored.
   * @param {string} document - The &#x60;document&#x60; parameter in the &#x60;getDocument&#x60; function represents the
   * specific document ID that you want to retrieve from the specified collection in the Firestore
   * database. It is used to identify the document within the collection and fetch its data.
   * @returns A Promise is being returned, which resolves to a FirebaseDocument object if the document
   * exists in the specified collection, and rejects with an error message if the database is not
   * connected or if the document does not exist.
   */
  public getDocument(
    collectionName: string,
    document: string
  ): Promise&lt;FirebaseDocument&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      if (!this._db)
        reject({
          msg: &#x27;Database is not connected&#x27;,
        });
      const docRef &#x3D; doc(this._db!, collectionName, document);
      const docSnap &#x3D; await getDoc(docRef);

      if (docSnap.exists()) {
        resolve({ id: docSnap.id, data: docSnap.data() });
      } else {
        // doc.data() will be undefined in this case
        reject(&#x27;document does not exists&#x27;);
      }
    });
  }

  /**
   * This TypeScript function retrieves documents from a Firestore collection based on a specified
   * field and value.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter refers to the name of the
   * collection in your Firestore database from which you want to retrieve documents. It is a string
   * that specifies the collection&#x27;s name.
   * @param {string} field - The &#x60;field&#x60; parameter in the &#x60;getDocumentsBy&#x60; function represents the
   * field in the Firestore collection that you want to query against. It is used to specify the field
   * on which you want to apply the equality condition in the query.
   * @param {any} value - The &#x60;value&#x60; parameter in the &#x60;getDocumentsBy&#x60; function represents the value
   * that you want to query for in the specified field of the documents in the collection. It is the
   * value that you are searching for in the database.
   * @returns The &#x60;getDocumentsBy&#x60; function returns a Promise that resolves to an array of
   * &#x60;FirebaseDocument&#x60; objects. Each &#x60;FirebaseDocument&#x60; object contains an &#x60;id&#x60; property representing
   * the document ID and a &#x60;data&#x60; property representing the document data.
   */
  public getDocumentsBy(
    collectionName: string,
    field: string,
    value: any
  ): Promise&lt;FirebaseDocument[]&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      if (!this._db)
        reject({
          msg: &#x27;Database is not connected&#x27;,
        });
      const q &#x3D; query(
        collection(this._db!, collectionName),
        where(field, &#x27;&#x3D;&#x3D;&#x27;, value)
      );

      const querySnapshot &#x3D; await getDocs(q);
      resolve(
        querySnapshot.docs.map&lt;FirebaseDocument&gt;((doc) &#x3D;&gt; {
          return { id: doc.id, data: doc.data() };
        })
      );
    });
  }

  /**
   * The function &#x60;deleteDocument&#x60; deletes a document from a specified collection in a database and
   * returns a promise indicating the success status.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter is a string that represents the
   * name of the collection from which you want to delete a document.
   * @param {string} docId - The &#x60;docId&#x60; parameter in the &#x60;deleteDocument&#x60; function represents the
   * unique identifier of the document that you want to delete from the specified collection in the
   * database. It is used to locate the specific document that needs to be removed.
   * @returns The &#x60;deleteDocument&#x60; function is returning a Promise that resolves to an object with a
   * &#x60;success&#x60; property set to a boolean value. The object structure being returned is &#x60;{ success:
   * boolean }&#x60;.
   */
  public deleteDocument(
    collectionName: string,
    docId: string
  ): Promise&lt;{ success: boolean }&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      try {
        if (!this._db) {
          throw new Error(&#x27;Database is not connected&#x27;);
        }
        const docRef &#x3D; doc(this._db, collectionName, docId);
        await deleteDoc(docRef);
        resolve({ success: true });
      } catch (error) {
        console.error(&#x27;Error deleting document:&#x27;, error);
        reject(error);
      }
    });
  }

  /**
   * The function &#x60;subscribeToCollection&#x60; subscribes to changes in a Firestore collection and updates a
   * BehaviorSubject with the mapped data.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter is a string that represents the
   * name of the collection in the Firestore database that you want to subscribe to for real-time
   * updates.
   * @param subject - The &#x60;subject&#x60; parameter is a BehaviorSubject that emits an array of items.
   * @param mapFunction - The &#x60;mapFunction&#x60; parameter in the &#x60;subscribeToCollection&#x60; function is a
   * function that takes a &#x60;DocumentData&#x60; object as input and returns any other type of object. This
   * function is used to transform the data from the Firestore document into the desired format before
   * emitting it to the &#x60;subject&#x60;.
   * @returns The &#x60;subscribeToCollection&#x60; function returns either an &#x60;Unsubscribe&#x60; function or &#x60;null&#x60;.
   */
  public subscribeToCollection(
    collectionName: string,
    subject: BehaviorSubject&lt;any[]&gt;,
    mapFunction: (el: DocumentData) &#x3D;&gt; any
  ): Unsubscribe | null {
    if (!this._db) return null;
    return onSnapshot(
      collection(this._db, collectionName),
      (snapshot) &#x3D;&gt; {
        subject.next(snapshot.docs.map&lt;any&gt;((doc) &#x3D;&gt; mapFunction(doc.data())));
      },
      (error) &#x3D;&gt; {}
    );
  }

  /**
   * The function &#x60;subscribeToDocument&#x60; subscribes to changes in a Firestore document and updates a
   * BehaviorSubject with the mapped data.
   * @param {string} documentPath - The &#x60;documentPath&#x60; parameter is a string that represents the path
   * to a specific document in a Firestore database.
   * @param subject - The &#x60;subject&#x60; parameter is an instance of &#x60;BehaviorSubject&lt;any&gt;&#x60;, which is a type
   * of subject in RxJS that stores the most recent value emitted to its subscribers and emits that
   * value immediately to new subscribers.
   * @param mapFunction - The &#x60;mapFunction&#x60; parameter in the &#x60;subscribeToDocument&#x60; function is a
   * function that takes a &#x60;DocumentData&#x60; object as input and returns any other type of data. This
   * function is used to transform the raw data from the Firestore document into a format that can be
   * emitted by the &#x60;subject&#x60;
   * @returns The &#x60;subscribeToDocument&#x60; function returns either an &#x60;Unsubscribe&#x60; function or &#x60;null&#x60;.
   */
  public subscribeToDocument(
    documentPath: string,
    subject: BehaviorSubject&lt;any&gt;,
    mapFunction: (el: DocumentData) &#x3D;&gt; any
  ): Unsubscribe | null {
    if (!this._db) {
      return null;
    }
    const documentRef: DocumentReference &#x3D; doc(this._db, documentPath);

    return onSnapshot(
      documentRef,
      (snapshot: DocumentSnapshot) &#x3D;&gt; {
        const data &#x3D; snapshot.data();
        if (data) {
          subject.next(mapFunction(data));
        }
      },
      (error) &#x3D;&gt; {
        console.error(&#x27;Error:&#x27;, error);
      }
    );
  }

  /**
   * The &#x60;signOut&#x60; function in TypeScript signs out the user and optionally signs in anonymously.
   * @param {boolean} [signInAnon&#x3D;false] - The &#x60;signInAnon&#x60; parameter is a boolean flag that indicates
   * whether the user should be signed in anonymously after signing out. If &#x60;signInAnon&#x60; is set to
   * &#x60;true&#x60;, the &#x60;connectAnonymously&#x60; method will be called after signing out.
   */
  public async signOut(signInAnon: boolean &#x3D; false): Promise&lt;void&gt; {
    new Promise&lt;void&gt;(async (resolve, reject) &#x3D;&gt; {
      if (this._auth)
        try {
          await this._auth.signOut();
          if (signInAnon) await this.connectAnonymously();
          resolve();
        } catch (error) {
          reject(error);
        }
    });
  }

  /**
   * The function &#x60;isUserConnected&#x60; returns a Promise that resolves to a boolean indicating whether a
   * user is currently connected.
   * @returns The &#x60;isUserConnected&#x60; function returns a Promise that resolves to a boolean value
   * indicating whether the user is connected or not.
   */
  public isUserConnected(): Promise&lt;boolean&gt; {
    const response &#x3D; new Promise&lt;boolean&gt;(async (resolve, reject) &#x3D;&gt; {
      if (!this._auth) resolve(false);
      resolve(this._auth!.currentUser !&#x3D; null);
    });
    return response;
  }

  /**
   * The function &#x60;isUserConnectedAnonymously&#x60; checks if the user is connected anonymously and returns
   * a Promise with a boolean value.
   * @returns A Promise that resolves to a boolean value indicating whether the user is connected
   * anonymously or not.
   */
  public isUserConnectedAnonymously(): Promise&lt;boolean&gt; {
    const response &#x3D; new Promise&lt;boolean&gt;(async (resolve, reject) &#x3D;&gt; {
      if (!this._auth) resolve(false);
      resolve(
        this._auth!.currentUser !&#x3D; null &amp;&amp; this._auth!.currentUser.isAnonymous
      );
    });
    return response;
  }

  /**
   * The function &#x60;connectAnonymously&#x60; connects a user anonymously if not already connected.
   * @returns A Promise is being returned from the &#x60;connectAnonymously&#x60; function.
   */
  public async connectAnonymously(): Promise&lt;void&gt; {
    const response &#x3D; new Promise&lt;void&gt;(async (resolve, reject) &#x3D;&gt; {
      if (!this._auth) resolve();
      if (
        !(await this.isUserConnected()) &amp;&amp;
        !(await this.isUserConnectedAnonymously())
      ) {
        await signInAnonymously(this._auth!).catch((error) &#x3D;&gt; reject(error));
        resolve();
      } else if (await this.isUserConnectedAnonymously()) resolve();
      else reject({ msg: &#x27;An user is already connected&#x27; });
    });
    return response;
  }

  /**
   * This TypeScript function creates a user with email and password authentication, handling various
   * error cases.
   * @param {string} email - The &#x60;email&#x60; parameter in the &#x60;createUserWithEmailAndPassword&#x60; function is
   * a string that represents the email address of the user you want to create an account for. It is
   * used as a unique identifier for the user&#x27;s account and must be in a valid email format (e.g.,
   * example@example.com).
   * @param {string} password - The &#x60;password&#x60; parameter in the &#x60;createUserWithEmailAndPassword&#x60;
   * function is a string that represents the password that the user wants to set for their account. It
   * is used to authenticate the user during the sign-up process and is typically required to meet
   * certain security criteria, such as having a minimum length, containing
   * @returns The &#x60;createUserWithEmailAndPassword&#x60; function is being called with the provided email and
   * password parameters. If successful, it returns a &#x60;FirebaseUserCredential&#x60; object containing
   * information about the user. If there is an error during the process, it logs specific error
   * messages based on the error code and then rejects the promise with the error.
   */
  public async createUserWithEmailAndPassword(
    email: string,
    password: string
  ): Promise&lt;FirebaseUserCredential | null&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      if (!this._auth) resolve(null);
      try {
        resolve({
          user: await createUserWithEmailAndPassword(
            this._auth!,
            email,
            password
          ),
        });
      } catch (error: any) {
        switch (error.code) {
          case &#x27;auth/email-already-in-use&#x27;:
            console.log(&#x60;Email address ${email} already in use.&#x60;);
            break;
          case &#x27;auth/invalid-email&#x27;:
            console.log(&#x60;Email address ${email} is invalid.&#x60;);
            break;
          case &#x27;auth/operation-not-allowed&#x27;:
            console.log(&#x60;Error during sign up.&#x60;);
            break;
          case &#x27;auth/weak-password&#x27;:
            console.log(
              &#x27;Password is not strong enough. Add additional characters including special characters and numbers.&#x27;
            );
            break;
          default:
            console.log(error.message);
            break;
        }
        reject(error);
      }
    });
  }

  /**
   * The function &#x60;connectUserWithEmailAndPassword&#x60; attempts to sign in a user with the provided email
   * and password using Firebase authentication and returns a &#x60;FirebaseUserCredential&#x60; or &#x60;null&#x60; in a
   * Promise.
   * @param {string} email - The &#x60;email&#x60; parameter is a string that represents the user&#x27;s email address
   * that they use to sign in.
   * @param {string} password - The &#x60;password&#x60; parameter in the &#x60;connectUserWithEmailAndPassword&#x60;
   * function is a string that represents the user&#x27;s password for authentication.
   * @returns The &#x60;connectUserWithEmailAndPassword&#x60; function returns a Promise that resolves to a
   * &#x60;FirebaseUserCredential&#x60; object if the sign-in is successful, or &#x60;null&#x60; if the authentication
   * object &#x60;_auth&#x60; is not available. If there is an error during sign-in, the Promise will be rejected
   * with the error.
   */
  public async connectUserWithEmailAndPassword(
    email: string,
    password: string
  ): Promise&lt;FirebaseUserCredential | null&gt; {
    return new Promise&lt;FirebaseUserCredential | null&gt;(
      async (resolve, reject) &#x3D;&gt; {
        if (!this._auth) resolve(null);
        try {
          const user &#x3D; await signInWithEmailAndPassword(
            this._auth,
            email,
            password
          );
          return { user };
        } catch (error) {
          reject(error);
          return error;
        }
      }
    );
  }

  /**
   * The function deleteUser deletes a user and returns a Promise that resolves when the user is
   * successfully deleted or rejects if there is no user to delete.
   * @returns The &#x60;deleteUser&#x60; method is returning a Promise that resolves with void.
   */
  public deleteUser(): Promise&lt;void&gt; {
    return new Promise&lt;void&gt;((resolve, reject) &#x3D;&gt; {
      if (!this._user) reject();
      resolve(deleteUser(this._user!));
    });
  }

  /**
   * The function &#x60;updateDocumentField&#x60; updates a specific field with a new value in a document within
   * a Firestore collection.
   * @param {string} collectionName - The &#x60;collectionName&#x60; parameter refers to the name of the
   * collection in the Firestore database where the document is located.
   * @param {string} document - The &#x60;document&#x60; parameter in the &#x60;updateDocumentField&#x60; function
   * represents the unique identifier of the document within the specified collection that you want to
   * update. It is a string value that identifies the specific document you want to modify in the
   * Firestore database.
   * @param {string} fieldName - The &#x60;fieldName&#x60; parameter in the &#x60;updateDocumentField&#x60; function
   * represents the name of the field in the document that you want to update. For example, if you have
   * a document in a Firestore collection with fields like &quot;name&quot;, &quot;age&quot;, &quot;email&quot;, etc., the
   * &#x60;fieldName&#x60; parameter would
   * @param {any} fieldValue - The &#x60;fieldValue&#x60; parameter in the &#x60;updateDocumentField&#x60; function
   * represents the new value that you want to set for the specified field (&#x60;fieldName&#x60;) in the
   * document identified by &#x60;document&#x60; within the collection &#x60;collectionName&#x60;. This value can be of any
   * data type (&#x60;string&#x60;, &#x60;number&#x60;, &#x60;
   * @returns This function &#x60;updateDocumentField&#x60; returns a Promise that resolves to void (undefined)
   * when the document field update operation is successful, or rejects with an error object if there
   * is an issue such as the database not being connected or an error during the update operation.
   */
  public updateDocumentField(
    collectionName: string,
    document: string,
    fieldName: string,
    fieldValue: any
  ): Promise&lt;void&gt; {
    return new Promise(async (resolve, reject) &#x3D;&gt; {
      if (!this._db) {
        reject({
          msg: &#x27;Database is not connected&#x27;,
        });
      }

      const documentRef &#x3D; doc(this._db as Firestore, collectionName, document);
      const fieldUpdate &#x3D; { [fieldName]: fieldValue }; // Crear un objeto con el campo a actualizar

      try {
        await updateDoc(documentRef, fieldUpdate);
        resolve();
      } catch (error) {
        reject(error);
      }
    });
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'FirebaseStorageFile.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
